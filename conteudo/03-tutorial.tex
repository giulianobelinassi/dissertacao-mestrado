% Vamos definir alguns comandos auxiliares para facilitar.

% "textbackslash" é muito comprido.
\newcommand{\sla}{\textbackslash}

% Vamos escrever comandos (como "make" ou "itemize") com formatação especial.
\newcommand{\cmd}[1]{\textsf{#1}}

% Idem para packages; aqui estamos usando a mesma formatação de \cmd,
% mas poderíamos escolher outra.
\newcommand{\pkg}[1]{\textsf{#1}}

% A maioria dos comandos LaTeX começa com "\"; vamos criar um
% comando que já coloca essa barra e formata com "\cmd".
\newcommand{\ltxcmd}[1]{\cmd{\sla{}#1}}

\chapter{Trabalhos Relacionados}
\label{chap:related_works}

Acelerar o processo de compilação pelo uso da computação paralela não é
uma novidade no mundo científico. \cite{Lincoln:1970:PPT:987475.987478}
propôs uma maneira de paralelizar a análise léxica de um compilador
Fortran simplesmente quebrando o código fonte em partes, mapeando as 
informações de final de
linha e a posição de cada caractere, e realizando o processamento
através de operações em APL.
Posteriormente, \cite{Krohn:1975:PAC:390015.808414} estendeu o trabalho
anterior, propondo uma maneira de realizar a análise sintática, a 
tradução para a AST, e a geração
de código utilizando os registradores vetoriais do supercomputador
STAR-100. Ambos os artigos também não apresentam nenhuma
análise assintótica para os algoritmos propostos, e também não apresentam
experimentos. 

Posteriormente, \cite{Mickunas:1978:PCM:800127.804105} propôs uma
paralelização do algoritmo LR($0$). Sua ideia consiste em quebrar
arbitrariamente a entrada em vários segmentos e executar um analisador em paralelo
em cada um destes segmentos. Estes analisadores (exceto o primeiro,
que executa no inicio da entrada) são modificados na tentativa de
evitar conflitos, uma vez que modificar a ordem de inicio da análise
pode impossibilitar distinguir entre o prefixo e o sufixo de uma fase.
Quando um conflito é detectado, o analisador envia a sequência de
\textit{tokens} lido até então para o analisador da esquerda,
retorna ao estado inicial, e reinicia a sua análise.
Quando o analisador termina, o seu resultado é enviado
ara o analisador à sua esquerda. Os autores não mostraram experimentos ou
análise assintótica do algoritmo proposto. \cite{Pennello:1978:FMA:512760.512786}
implementou essa estratégia em um compilador Pascal, mas seus experimentos foram
realizados em um computador paralelo simulado.

\cite{vandevoorde1988parallel} paralelizou o \textit{Titan C compiler}, um compilador
C escrito em Modula-2. Sua implementação utiliza um analisador léxico executando
independentemente ao analisador sintático, e os \textit{tokens} são fornecidos
através de um \textit{pipeline}. Ele também propôs uma paralelização de um
analisador sintático recursivo descendente, executando novas \textit{threads}
para cada expressão da gramática após a sequência de declarações do programa,
requerindo com que qualquer declaração de funções do programa esteja no cabeçalho do
arquivo. Essa estratégia de granularidade fina necessitou a implementação de
uma maneira de controlar o paralelismo, onde foi utilizado o conceito de
WorkCrews \citep{vandevoorde1988workcrews}, limitando o número máximo de
\textit{threads} em execução simultânea. O autor relata um ganho de 10\% ao
utilizar um \textit{pipeline} entre o analisador léxico e sintático, e um
\textit{speedup} de até $3.1\times$ utilizando 5 processadores MicroVax II em
memória compartilhada.  Entretanto, o compilador não possui estágios de
otimização e o autor não discute como paralelizar um otimizador.

De maneira similar, \cite{wortman1992} construiu um compilador de Modula-2+
paralelo. A estratégia proposta é utilizar um analisador léxico capaz de
encontrar funções no código fonte e prosseguir com a compilação em paralelo
nesse nível, gerando uma tarefa para cada função. Para solucionar problemas
relacionados a chamada de funções e
acesso à símbolos ainda não definidos, o autor propõe o uso de
uma lógica ternária na tabela de símbolos, especificando um estado
"Doesn't know yet" (Ainda não visto), e propõe três estratégias para
implementar essa funcionalidade. Em seguida, o autor propõe o uso de
um número fixo de \textit{threads} trabalhadoras, e o uso de uma fila de
prioridade produtor consumidor, onde as \textit{threads} deverão retirar o trabalho.
O uso de uma fila de prioridade permite com que as funções mais longas sejam
processadas primeiro. Os experimentos conduzidos pelo autor mostraram
\textit{speedups} variando de $1.5\times$ até $6\times$ utilizando 8
processadores MicroVAX II em memória compartilhada.

Deve ser destacado que os artigos até então não abordam questões relacionadas
a otimização de código. Isso porque os compiladores até então haviam poucos
passos de otimização, o que implicava em pouco tempo necessário para fazê-la.

Mesmo assim, alguns pesquisadores dedicaram-se a estudar esses passos.
\cite{Lee1994} estudou maneiras de explorar paralelismo na análise de controle
de fluxo. Os autores argumentam que os compiladores otimizadores gastam a maior
parte do tempo realizando tais análises, principalmente nas otimizações Inter
Procedurais. A análise se concentra em algoritmos que usam o grafo de controle
de fluxo como entrada, sendo assim os autores propõem uma heurística de aglutinação
para particionar tal grafo em regiões conexas e adjacentes de tamanho não maior que $s$, já que o
problema geral é NP-difícil. Os autores experimentam sua implementação utilizando
8 processadores do iPSC/2 em memória distribuída, e adquiriram \textit{speedups} variando de
$2.8 \times$ até $6.5\times$. Os autores relataram que vários dos programas utilizados nos
testes consistiam de várias funções pequenas, o que limitava o \textit{speedup} nas análises
intra procedurais. Uma outra forma de explorar o paralelismo nessas estruturas
foi proposta por \cite{kramer1994combining}.

Após estes resultados, houve um aparente hiato nas pesquisas relacionadas a
compilação em paralelo.




 Entretanto, deve ser destacado que os compiladores
daquela época eram simples, geravam código ineficiente, e a entrada/saída
era realizada através de cartões perfurados, o que configura uma situação
bem diferente da atual. 
